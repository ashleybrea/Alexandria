from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict
import uvicorn
from dataclasses import dataclass
import re

app = FastAPI(title="Project Alexandria", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",  # React dev server
        "http://127.0.0.1:3000",  # Alternative localhost format
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["*"],
)

class MentorProfile(BaseModel):
    id: Optional[str] = None  # UUID generated by database
    email: str
    password_hash: str
    name: str
    pronouns: Optional[str] = None
    location: Optional[str] = None
    preferred_meeting_frequency: Optional[str] = None
    mentor_style: Optional[str] = None
    skills: List[str] = []  # Required field from schema
    interests: List[str] = []  # Required field from schema
    session_structure: Optional[str] = None
    fields_of_expertise: List[str] = []  # Required field from schema
    preferred_contact_method: Optional[str] = None
    role: Optional[str] = None
    department: Optional[str] = None
    education: Optional[str] = None
    current_mentees: Optional[int] = 0
    max_mentees: Optional[int] = 0
    work_experience: Optional[str] = None
    bio: Optional[str] = None
    microsoft_teams_id: Optional[str] = None

class MenteeProfile(BaseModel):
    id: Optional[str] = None  # UUID generated by database
    email: str
    password_hash: str
    name: str
    pronouns: Optional[str] = None
    location: Optional[str] = None
    preferred_meeting_frequency: Optional[str] = None
    mentor_style: Optional[str] = None
    skills: List[str] = []  # Required field from schema
    interests: List[str] = []  # Required field from schema
    session_structure: Optional[str] = None
    fields_of_expertise: List[str] = []  # Required field from schema
    preferred_contact_method: Optional[str] = None
    role: Optional[str] = None
    department: Optional[str] = None
    education: Optional[str] = None
    work_experience: Optional[str] = None
    bio: Optional[str] = None
    microsoft_teams_id: Optional[str] = None

class MatchResult(BaseModel):
    profile: dict
    compatibility_score: float
    matching_areas: List[str]
    total_matches: int

# In-memory storage (replace with actual database calls later)
mentors_db: Dict[str, MentorProfile] = {}
mentees_db: Dict[str, MenteeProfile] = {}

# Initialize with example data
def initialize_example_data():
    """Initialize the database with diverse example mentor and mentee profiles"""
    
    # Example Mentors with diverse backgrounds
    example_mentors = [
        MentorProfile(
            id="mentor_1",
            email="sarah.johnson@tech.com",
            password_hash="hashed_password_1",
            name="Sarah Johnson",
            pronouns="she/her",
            location="San Francisco, CA",
            preferred_meeting_frequency="Weekly",
            mentor_style="Hands-on",
            skills=["Python", "Machine Learning", "Data Science", "TensorFlow", "SQL"],
            interests=["AI Ethics", "Teaching", "Open Source"],
            fields_of_expertise=["Machine Learning", "Data Science", "AI"],
            preferred_contact_method="Video Call",
            role="Senior Data Scientist",
            department="Engineering",
            education="PhD Computer Science",
            current_mentees=1,
            max_mentees=3,
            work_experience="8 years in tech, 3 years mentoring",
            bio="Passionate about making AI accessible and ethical. Love helping newcomers break into data science.",
            microsoft_teams_id="sarah.johnson@tech.com"
        ),
        MentorProfile(
            id="mentor_2",
            email="marcus.chen@startup.io",
            password_hash="hashed_password_2",
            name="Marcus Chen",
            pronouns="he/him",
            location="Austin, TX",
            preferred_meeting_frequency="Bi-weekly",
            mentor_style="Goal-oriented",
            skills=["JavaScript", "React", "Node.js", "AWS", "Docker"],
            interests=["Entrepreneurship", "Product Development", "Team Leadership"],
            fields_of_expertise=["Full-stack Development", "Cloud Architecture", "Startup Strategy"],
            preferred_contact_method="In-person",
            role="CTO",
            department="Executive",
            education="MS Software Engineering",
            current_mentees=2,
            max_mentees=2,
            work_experience="10 years, founded 2 startups",
            bio="Former founder turned CTO. Help engineers grow into technical leaders and entrepreneurs.",
            microsoft_teams_id="marcus.chen@startup.io"
        ),
        MentorProfile(
            id="mentor_3",
            email="priya.patel@design.co",
            password_hash="hashed_password_3",
            name="Priya Patel",
            pronouns="she/her",
            location="New York, NY",
            preferred_meeting_frequency="Monthly",
            mentor_style="Creative",
            skills=["UI/UX Design", "Figma", "User Research", "Prototyping", "Design Systems"],
            interests=["Accessibility", "Design Psychology", "Mentoring Women in Tech"],
            fields_of_expertise=["Product Design", "User Experience", "Design Leadership"],
            preferred_contact_method="Chat",
            role="Senior UX Designer",
            department="Design",
            education="BFA Graphic Design",
            current_mentees=0,
            max_mentees=4,
            work_experience="6 years in design, 2 years mentoring",
            bio="Advocate for inclusive design. Specialize in creating user-centered products that make a difference.",
            microsoft_teams_id="priya.patel@design.co"
        ),
        MentorProfile(
            id="mentor_4",
            email="david.kim@enterprise.com",
            password_hash="hashed_password_4",
            name="David Kim",
            pronouns="he/him",
            location="Seattle, WA",
            preferred_meeting_frequency="Weekly",
            mentor_style="Structured",
            skills=["Java", "Spring", "Microservices", "Kubernetes", "System Design"],
            interests=["Architecture", "Scalability", "Code Quality"],
            fields_of_expertise=["Backend Development", "System Architecture", "Enterprise Software"],
            preferred_contact_method="Video Call",
            role="Principal Engineer",
            department="Platform",
            education="MS Computer Science",
            current_mentees=3,
            max_mentees=3,
            work_experience="12 years in enterprise software",
            bio="Specialist in building scalable systems. Help engineers master backend development and system design.",
            microsoft_teams_id="david.kim@enterprise.com"
        )
    ]
    
    # Example Mentees with diverse interests and experience levels
    example_mentees = [
        MenteeProfile(
            id="mentee_1",
            email="alex.smith@student.edu",
            password_hash="hashed_password_5",
            name="Alex Smith",
            pronouns="they/them",
            location="Boston, MA",
            preferred_meeting_frequency="Weekly",
            mentor_style="Hands-on",
            skills=["Python", "Statistics", "R"],
            interests=["Machine Learning", "Data Science", "AI Ethics"],
            fields_of_expertise=["Data Analysis"],
            preferred_contact_method="Video Call",
            role="Graduate Student",
            department="Computer Science",
            education="BS Mathematics, pursuing MS Data Science",
            work_experience="1 year research assistant, internships",
            bio="Math background transitioning to data science. Passionate about ethical AI and social impact.",
            microsoft_teams_id="alex.smith@student.edu"
        ),
        MenteeProfile(
            id="mentee_2",
            email="emily.rodriguez@bootcamp.com",
            password_hash="hashed_password_6",
            name="Emily Rodriguez",
            pronouns="she/her",
            location="Los Angeles, CA",
            preferred_meeting_frequency="Bi-weekly",
            mentor_style="Goal-oriented",
            skills=["HTML", "CSS", "JavaScript", "React"],
            interests=["Frontend Development", "Web Design", "Career Change"],
            fields_of_expertise=["Web Development"],
            preferred_contact_method="Video Call",
            role="Bootcamp Student",
            department="Education",
            education="Coding Bootcamp (in progress), BA English Literature",
            work_experience="5 years in marketing, transitioning to tech",
            bio="Former marketing professional learning to code. Goal is to become a frontend developer.",
            microsoft_teams_id="emily.rodriguez@bootcamp.com"
        ),
        MenteeProfile(
            id="mentee_3",
            email="jordan.lee@junior.dev",
            password_hash="hashed_password_7",
            name="Jordan Lee",
            pronouns="he/him",
            location="Chicago, IL",
            preferred_meeting_frequency="Weekly",
            mentor_style="Structured",
            skills=["Java", "Spring Boot", "SQL", "Git"],
            interests=["Backend Development", "System Design", "Career Growth"],
            fields_of_expertise=["Backend Development"],
            preferred_contact_method="In-person",
            role="Junior Developer",
            department="Engineering",
            education="BS Computer Science",
            work_experience="1 year as junior developer",
            bio="Recent CS grad working as junior backend developer. Want to learn system design and advance to senior level.",
            microsoft_teams_id="jordan.lee@junior.dev"
        ),
        MenteeProfile(
            id="mentee_4",
            email="maya.singh@designer.new",
            password_hash="hashed_password_8",
            name="Maya Singh",
            pronouns="she/her",
            location="Portland, OR",
            preferred_meeting_frequency="Monthly",
            mentor_style="Creative",
            skills=["Sketch", "Adobe Creative Suite", "Wireframing"],
            interests=["UX Design", "Accessibility", "Design Systems"],
            fields_of_expertise=["Graphic Design"],
            preferred_contact_method="Chat",
            role="Graphic Designer",
            department="Marketing",
            education="BFA Graphic Design",
            work_experience="3 years graphic design, transitioning to UX",
            bio="Graphic designer wanting to transition to UX/UI design. Interested in accessibility and inclusive design.",
            microsoft_teams_id="maya.singh@designer.new"
        ),
        MenteeProfile(
            id="mentee_5",
            email="carlos.martinez@newgrad.com",
            password_hash="hashed_password_9",
            name="Carlos Martinez",
            pronouns="he/him",
            location="Miami, FL",
            preferred_meeting_frequency="Bi-weekly",
            mentor_style="Hands-on",
            skills=["Python", "JavaScript", "React", "Node.js"],
            interests=["Full-stack Development", "Startups", "Entrepreneurship"],
            fields_of_expertise=["Web Development"],
            preferred_contact_method="Video Call",
            role="New Graduate",
            department="Engineering",
            education="BS Computer Science",
            work_experience="Internships and personal projects",
            bio="Recent CS graduate interested in full-stack development and eventually starting my own company.",
            microsoft_teams_id="carlos.martinez@newgrad.com"
        )
    ]
    
    # Add mentors to database
    for mentor in example_mentors:
        mentors_db[mentor.id] = mentor
    
    # Add mentees to database
    for mentee in example_mentees:
        mentees_db[mentee.id] = mentee
    
    print(f"Initialized with {len(example_mentors)} mentors and {len(example_mentees)} mentees")

# Initialize example data when the module loads
initialize_example_data()

class MatchingAlgorithm:
    @staticmethod
    # Basic matching algorithm based on overlapping interest/expert areas
    # experienece compatibility, mentee availability, etc.
    def calculate_compatibility(mentor: MentorProfile, mentee: MenteeProfile) -> float:
        # Normalize areas to lowercase for better matching
        mentor_areas = [area.lower().strip() for area in mentor.fields_of_expertise]
        mentee_areas = [area.lower().strip() for area in mentee.interests]
        
        # Find overlapping areas
        matching_areas = list(set(mentor_areas) & set(mentee_areas))
        
        # Calculate basic overlap score
        if len(mentee_areas) == 0:
            overlap_score = 0
        else:
            overlap_score = len(matching_areas) / len(mentee_areas)
        
        # Experience compatibility factor
        # Since work_experience is now text-based, we'll use a simpler approach
        # In the future, this could be enhanced to parse experience levels from text
        exp_factor = 1.0  # Default neutral factor
        
        # Mentor capacity factor - consider current vs max mentees
        mentor_capacity_factor = 1.0
        if mentor.max_mentees and mentor.current_mentees is not None:
            if mentor.current_mentees < mentor.max_mentees:
                mentor_capacity_factor = 1.2  # Bonus for available capacity
            else:
                mentor_capacity_factor = 0.5  # Penalty for no capacity
        
        # Final compatibility score
        compatibility_score = overlap_score * exp_factor * mentor_capacity_factor
        
        return {
            "compatibility_score": round(compatibility_score, 3),
            "matching_areas": matching_areas,
            "total_matches": len(matching_areas),
            "overlap_percentage": round(overlap_score * 100, 1)
        }
    @staticmethod
    def find_mentor_matches(mentee: MenteeProfile, mentors: Dict[str, MentorProfile], limit: int = 5) -> List[MatchResult]:
        """Find best mentor matches for a mentee"""
        matches = []
        
        for mentor_id, mentor in mentors.items():
            compatibility = MatchingAlgorithm.calculate_compatibility(mentor, mentee)
            
            if compatibility["total_matches"] > 0:  # Only include if there's at least one match
                match_result = MatchResult(
                    profile=mentor.dict(),
                    compatibility_score=compatibility["compatibility_score"],
                    matching_areas=compatibility["matching_areas"],
                    total_matches=compatibility["total_matches"]
                )
                matches.append(match_result)
        
        # Sort by compatibility score (descending)
        matches.sort(key=lambda x: x.compatibility_score, reverse=True)
        
        return matches[:limit]
    @staticmethod
    def find_mentee_matches(mentor: MentorProfile, mentees: Dict[str, MenteeProfile], limit: int = 5) -> List[MatchResult]:
        """Find best mentee matches for a mentor"""
        matches = []
        
        for mentee_id, mentee in mentees.items():
            compatibility = MatchingAlgorithm.calculate_compatibility(mentor, mentee)
            
            if compatibility["total_matches"] > 0:  # Only include if there's at least one match
                match_result = MatchResult(
                    profile=mentee.dict(),
                    compatibility_score=compatibility["compatibility_score"],
                    matching_areas=compatibility["matching_areas"],
                    total_matches=compatibility["total_matches"]
                )
                matches.append(match_result)
        
        # Sort by compatibility score (descending)
        matches.sort(key=lambda x: x.compatibility_score, reverse=True)
        
        return matches[:limit]


# API Endpoints

# Mentor endpoints
@app.post("/mentors/", response_model=dict)
async def create_mentor(mentor: MentorProfile):
    """Create a new mentor profile"""
    mentor_id = str(len(mentors_db) + 1)  # Simple ID generation (replace with UUID in production)
    mentor.id = mentor_id
    mentors_db[mentor_id] = mentor
    return {"message": "Mentor created successfully", "mentor_id": mentor_id}

@app.get("/mentors/", response_model=List[MentorProfile])
async def get_all_mentors():
    """Get all mentor profiles"""
    return list(mentors_db.values())

@app.get("/mentors/{mentor_id}", response_model=MentorProfile)
async def get_mentor(mentor_id: str):
    """Get a specific mentor by ID"""
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    return mentors_db[mentor_id]

@app.put("/mentors/{mentor_id}", response_model=dict)
async def update_mentor(mentor_id: str, mentor: MentorProfile):
    """Update an existing mentor profile"""
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    mentor.id = mentor_id
    mentors_db[mentor_id] = mentor
    return {"message": "Mentor updated successfully"}

@app.delete("/mentors/{mentor_id}", response_model=dict)
async def delete_mentor(mentor_id: str):
    """Delete a mentor profile"""
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    del mentors_db[mentor_id]
    return {"message": "Mentor deleted successfully"}

# Mentee endpoints
@app.post("/mentees/", response_model=dict)
async def create_mentee(mentee: MenteeProfile):
    """Create a new mentee profile"""
    mentee_id = str(len(mentees_db) + 1)  # Simple ID generation (replace with UUID in production)
    mentee.id = mentee_id
    mentees_db[mentee_id] = mentee
    return {"message": "Mentee created successfully", "mentee_id": mentee_id}

@app.get("/mentees/", response_model=List[MenteeProfile])
async def get_all_mentees():
    """Get all mentee profiles"""
    return list(mentees_db.values())

@app.get("/mentees/{mentee_id}", response_model=MenteeProfile)
async def get_mentee(mentee_id: str):
    """Get a specific mentee by ID"""
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    return mentees_db[mentee_id]

@app.put("/mentees/{mentee_id}", response_model=dict)
async def update_mentee(mentee_id: str, mentee: MenteeProfile):
    """Update an existing mentee profile"""
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    mentee.id = mentee_id
    mentees_db[mentee_id] = mentee
    return {"message": "Mentee updated successfully"}

@app.delete("/mentees/{mentee_id}", response_model=dict)
async def delete_mentee(mentee_id: str):
    """Delete a mentee profile"""
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    del mentees_db[mentee_id]
    return {"message": "Mentee deleted successfully"}

# Matching endpoints
@app.get("/mentees/{mentee_id}/matches", response_model=List[MatchResult])
async def find_mentors_for_mentee(mentee_id: str, limit: int = 5):
    """Find mentor matches for a specific mentee"""
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    
    mentee = mentees_db[mentee_id]
    matches = MatchingAlgorithm.find_mentor_matches(mentee, mentors_db, limit)
    return matches

@app.get("/mentors/{mentor_id}/matches", response_model=List[MatchResult])
async def find_mentees_for_mentor(mentor_id: str, limit: int = 5):
    """Find mentee matches for a specific mentor"""
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    
    mentor = mentors_db[mentor_id]
    matches = MatchingAlgorithm.find_mentee_matches(mentor, mentees_db, limit)
    return matches

@app.post("/match/compatibility")
async def calculate_compatibility_score(request: dict):
    """Calculate compatibility score between a specific mentor and mentee"""
    mentor_id = request.get("mentor_id")
    mentee_id = request.get("mentee_id")
    
    if not mentor_id or not mentee_id:
        raise HTTPException(status_code=400, detail="Both mentor_id and mentee_id are required")
    
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    
    mentor = mentors_db[mentor_id]
    mentee = mentees_db[mentee_id]
    compatibility = MatchingAlgorithm.calculate_compatibility(mentor, mentee)
    return compatibility

# Microsoft Teams integration endpoints
@app.get("/mentors/{mentor_id}/teams-link")
async def get_mentor_teams_link(mentor_id: str):
    """Generate Microsoft Teams deep link to message a mentor"""
    if mentor_id not in mentors_db:
        raise HTTPException(status_code=404, detail="Mentor not found")
    
    mentor = mentors_db[mentor_id]
    if not mentor.microsoft_teams_id:
        raise HTTPException(status_code=400, detail="Mentor has no Microsoft Teams ID configured")
    
    # Generate Teams deep link URL for starting a chat
    teams_link = f"https://teams.microsoft.com/l/chat/0/0?users={mentor.microsoft_teams_id}"
    
    return {
        "mentor_name": mentor.name,
        "teams_link": teams_link,
        "teams_id": mentor.microsoft_teams_id,
        "message": f"Click to start a chat with {mentor.name} on Microsoft Teams"
    }

@app.get("/mentees/{mentee_id}/teams-link")
async def get_mentee_teams_link(mentee_id: str):
    """Generate Microsoft Teams deep link to message a mentee"""
    if mentee_id not in mentees_db:
        raise HTTPException(status_code=404, detail="Mentee not found")
    
    mentee = mentees_db[mentee_id]
    if not mentee.microsoft_teams_id:
        raise HTTPException(status_code=400, detail="Mentee has no Microsoft Teams ID configured")
    
    # Generate Teams deep link URL for starting a chat
    teams_link = f"https://teams.microsoft.com/l/chat/0/0?users={mentee.microsoft_teams_id}"
    
    return {
        "mentee_name": mentee.name,
        "teams_link": teams_link,
        "teams_id": mentee.microsoft_teams_id,
        "message": f"Click to start a chat with {mentee.name} on Microsoft Teams"
    }

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "mentors_count": len(mentors_db), "mentees_count": len(mentees_db)}

# Run the application
if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)